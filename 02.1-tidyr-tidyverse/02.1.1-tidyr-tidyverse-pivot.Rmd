





## Same info, diff data

Typically data summaries found in textbooks don't show the underlying raw data file. In epidemiology and biostatistics, many statistics are calculated using counts of binary outcomes in a 2x2 contingency tables (`positive test`/`negative test`, `disease`/`no disease`, etc). Presenting the data this way allows for an easier calculation of odds ratios, relative risks, sensitivity, specificity, etc. Unfortunately, these 2x2 tables don't tell us anything about the structure of the underlying data. 

For example, let's assume we're looking at the results of an experiment that tested a binary outcome in two groups.

**Experimental Results:**

|               | Outcome       | No Outcome    | Total         |
| ------------- | ------------- | ------------- | ------------- |
| Treatment     | 3             | 206           | 209           |
| Control       | 26            | 180           | 206           |
| Total         | 29            | 386           | 415           |


The contingency table above displays the results grouped neatly by group (`Treatment` and `Control`) and outcome (`No Outcome` or `Outcome`). 

What would these data look like in a spreadsheet or .csv file? We can see there must be a variable for `group` assignment and `result`s, and these would need to be recorded by patient. So the data might have the arrangement we see below in the `TrialData` data frame. 

```{r TrialData, eval=TRUE, message=FALSE, warning=FALSE, echo=FALSE}
base::source("data/trial-data.R")
TrialData %>% dplyr::glimpse(78)
```

### How are summary tables created?

Summary tables display counts and summary statistics, but usually the data used to create these tables exist in a different format. For example, customer sales and subscription data might get stored in a relational database, but various SQL commands would be used to create a summary table for reporting. 

The 2x2 contingency table above is an example of how drastically these functions change the shape of a data frame. The primary `tidyverse` functions that make these types of transformations possible are `dplyr::group_by()` + `dplyr::summarize()` and `tidyr::spread()` + `tidyr::gather()`. 

Take a look at the `head()` of the `TrialData` data frame. 

```{r TrialData-head, eval=TRUE, echo=FALSE, results='hold'}
knitr::kable(
  TrialData %>% head()
)
```

Note how different these two tables look--it's hard to believe both tables are showing the same data! But If we wanted to get these data to display an aggregated display like the 2x2 table above, we could use a combination of `dplyr` and `tidyr` functions. 

```{r contingency-1, eval=TRUE, results='hold'}
knitr::kable(
  TrialData %>%
    dplyr::group_by(result, group) %>%
    dplyr::summarize(count = n()) %>%
    tidyr::spread(result, count) %>%
    dplyr::select(outcome, `no outcome`) %>%
    dplyr::arrange(outcome)
)
```

As you can see, both tables contain the same information, they're just arranged in a different way. 

### What do these functions do?

**Step 1:** The `dplyr::group_by()` function separates the data into any number of groups (`result` and `group` in our case), then `dplyr::summarize()` is combined with various aggregation functions (`sum()`, `n()`, `mean()`, etc.) to calculate summary statistics for each of the groups being compared. The last portion of this inital step is to `dplyr::ungroup()` the data table.

```{r 3-by-5-contingency, eval=TRUE, results='hold'}
knitr::kable(
  TrialData %>%
    dplyr::group_by(result, group) %>%
    dplyr::summarize(count = n()) %>%
    dplyr::ungroup()
)
```

Notice these steps don't create the 2x2 table (they create a 3x5 table). And we haven't changed much in terms of the table's shape: `result` and `group` are columns in both data sets, so all we've done is add the `count` column (in fact, the `dplyr::count()` function does exactly this, but I'm using the more verbose method to demonstrate whats happening under the hood).

**Step 2:** To create the 2x2 table we need to use `tidyr::spread()` to rotate the row contents across the columns--or to **pivot** the `result` and `count` columns--from a vertically aligned display to a horizontally arranged display. 

```{r contingency-table-2, eval=TRUE, results='hold'}
TrialData2x2 <- TrialData %>%
  dplyr::group_by(result, group) %>%
  dplyr::summarize(count = n()) %>%
  dplyr::ungroup() %>%
  # spread result and count across the the columns
  tidyr::spread(
    key = result,
    value = count
  ) %>% 
  dplyr::select(outcome, `no outcome`) %>%
    dplyr::arrange(outcome)
knitr::kable(TrialData2x2)
```

The `tidyverse` has a handful of functions for creating new columns and rows so our 2x2 table looks identical to the **Experiment Results** table above. I use a combination of `dplyr` functions below to create a 3x3 table with totals by row and column. 

```{r contingency-table-3, eval=TRUE, results='hold'}
TrialData3x3 <- TrialData %>%
  dplyr::group_by(result, group) %>%
  dplyr::summarize(count = n()) %>%
  dplyr::ungroup() %>%
  # spread result and count across the the columns
  tidyr::spread(
    key = result,
    value = count
  ) %>%
  # get rowwise totals
  dplyr::rowwise() %>%
  dplyr::mutate(TOTAL = sum(`no outcome` + outcome)) %>%
  # ungroup
  dplyr::ungroup() %>%
  # summarize all and bind to bottom of data set
  bind_rows(dplyr::summarise_all(
    .,
    list(~ if (is.numeric(.)) {
      sum(.)
    } else {
      "TOTAL"
    }))) %>% 
    dplyr::select(group, 
                  outcome,
                  `no outcome`,
                  TOTAL) %>% 
    dplyr::arrange(outcome)
knitr::kable(TrialData3x3)
```


## Pivoting

All this data manipulation brings us to *pivoting*, the [recent additions](https://tidyr.tidyverse.org/dev/articles/pivot.html) to the `tidyr` package. These functions will be slowly replacing the previous functions for reshaping data frames, `tidyr::gather()` and `tidyr::spread()`. I found it refreshing to learn that I wasn't the only person struggling to use these functions. Hadley Wickham, the package developer/author, confessed he also struggles when using these functions,

> Many people don’t find the names intuitive and find it hard to remember which direction corresponds to spreading and which to gathering. It also seems surprisingly hard to remember the arguments to these functions, meaning that many people (including me!) have to consult the documentation every time.

Statements like these are examples of why I appreciate the `tidyverse`, because I can tell a lot of thought gets put into identifying verbs that accurately capture the users intentions. Knowing how to reshape data is an important skill for data scientists, and I think the `tidyr::pivot_` functions are great additions to data manipulation in the `tidyverse`. 

### It's like having fancy footwork

Vasily Lomachenko, the best [pound-for-pound boxer](https://en.wikipedia.org/wiki/Boxing_pound_for_pound_rankings) in the world, is known for taking [traditional Ukrainian dance classes as a child before ever stepping into a boxing ring](traditional Ukrainian dance classes). Why would an athlete who punches people for a living spend time learning how to dance? Because having precise footwork and the ability to change direction sharply is so essential in boxing that these skills are often what separates a good fighter from an elite athlete.

```{r images/loma-pivot.gif, echo=FALSE, eval=TRUE, fig.cap="http://fightland.vice.com/blog/the-pivots-and-precision-of-vasyl-lomachenko"}
# fs::dir_ls("images")
knitr::include_graphics(path = "images/loma-pivot.gif")
```

As you can see, Lomachenko's pivoting abilities not only make him frustratingly hard to hit, but they also allow him to see openings in his opponents defense (which makes him incredibly successful at landing punches). 

```{r loma-pivot-strike.gif, echo=FALSE, eval=TRUE, fig.cap="http://fightland.vice.com/blog/the-pivots-and-precision-of-vasyl-lomachenko"}
# fs::dir_ls("images")
knitr::include_graphics(path = "images/loma-pivot-strike.gif")
```

*Why am I telling you about Vasyl Lomachenko's footwork?*

The `tidyr::pivot_` functions give you a similar ability with your data. Being able to rapidly rotate your data from columns to rows (and back) is similar to being able to turn 90 degrees on a dime and avoid an incoming punch (or to see an opening and land a stiff jab).

> "I think footwork is one of the most important things to becoming a great fighter. That's where everything starts." - Vasyl Lomachenko

We're going to start by manipulating a data set of Lomachenko's fights from the [BoxRec](http://boxrec.com/en/boxer/659771) database. The fight information has been entered in a way that makes sense for the person entering the data, but it's not ideal for analysis or modeling.

## Lomachenko fight data 

We will load Lomachenko's fight record from Wikipedia and explore how to use these new functions. To see how these data are created, check out the script file [here](https://github.com/mjfrigaard/storybenchR/blob/master/02.1-tidyr-tidyverse/loma-fights-wikipedia.R)

```{r LomaFightsWide, eval=TRUE, message=FALSE, warning=FALSE}
# fs::dir_ls("data")
LomaFightsWide <- readr::read_csv(file = "data/2019-03-29-LomaFightsWide.csv")
```

```{r loma-wide.png, eval=TRUE, echo=FALSE}
# fs::dir_ls("images")
knitr::include_graphics(path = "images/loma-wide.png")
```

## Are these data tidy?

These data are not tidy because the dates for each fight are in a separate columns. Formatting the data this way might seem odd to a data scientist, but this configuration makes sense for a fan entering the fights into a spreadsheet as they happen in real time. Consider the the chronological chain of events involved with a each fight, 

1. An opponent and location is announced, and an excited fan enters the information into the first two column/rows in a spreadsheet and titles it, 'Lomachenko` 
2. In order to track an athlete's win/loss record over the course of their career, a number is also marked for each fight (starting with `1`) in a column titled, `fight_number`
3. The date for the first fight gets entered into the `D` column (the fourth in the table), and the result gets put in the corresponding cell 
4. After the scorecards are collected, the technical `result` is announced (see key below), the `fight_record` is updated (with the official outcome of the bout)
5. The official round and time (`round_time`) is recorded for when the fight had to stop (or the total number of rounds if it went the distance), 
6. Titles and belts are listed in the `notes` section 
7. When the next fight happens, our fan right-clicks on the last recorded fight, and inserts a new column 
8. Steps 1-6 get repeated, and this table grows 

As you can see, the steps above are sensible for someone wanting to track their favorite athlete (or sports team) over time. I think of this data arrangement as *data-entry friendly*, because the table captures enough information to be useful, and it has a few computational abilities. For example, a fan could use filtering to count the number of `TKO`s a fighter has, or sort the `fight_record` column to figure what Lomachenko's record. Spreadsheets like these are a cross between a timeline and a record book, and they do a good enough job at both tasks to justify their current structure.

The [pivot vignette](https://tidyr.tidyverse.org/dev/articles/pivot.html#wide-to-long) conveys that 'wide' formats or data arrangements are common because their primary purpose and design is centered around recording data (and not visualization or modeling), 

> ...wild-caught datasets as they often optimize for ease of data entry or ease of comparison rather than ease of analysis. 

The `LomaFightsWide` data is one of these *wild-caught* data sets. 

## Pivoting from wide (to longer)

Before diving into the `pivot_longer` function and it's arguments, I want to imagine how the data I have will look in a tidy format. The figure below demonstrates how I'm envisioning the `LomaFightsWide` in a tidy arrangement.

```{r tidy-pivoting-longer, eval=TRUE, echo=FALSE}
# fs::dir_ls("images")
knitr::include_graphics(path = "images/tidy-pivoting-longer.png")
```

Using the figure as a guide, I can see the first thing I'm going to do is reorganize the columns to make these data easier to see in the RMarkdown file. I'll start with the `opponent` variable, list out each date column with the fight results, and then all of the remaining variables. 

```{r reorg-LomaFightsWide, eval=TRUE}
LomaFightsWide <- LomaFightsWide %>%
  dplyr::select(
    opponent,
    `12 Oct 2013`:`12 Apr 2019`,
    dplyr::everything()
  )
```

*Why start with the `opponent` variable?* Because the two pieces of information I am most interested in is 1) who Lomachenko fought, and 2) the outcome of the fight. That means I need each of these in their own variable. Right now I only have the `opponent`, so I need to create a `result` column.

```{r opponent-glimpse, eval=FALSE, echo=TRUE}
LomaFightsWide %>% dplyr::glimpse(78)
```

```{r loma-wide-reorganize, eval=TRUE, echo=FALSE}
# fs::dir_ls("images")
knitr::include_graphics(path = "images/loma-wide-reorganize.png")
```

If I'm sticking with the boxing analogy, the `opponent` column represents the leg I plant firmly on the ground, and the individual date columns are the opposite leg that rotates 90 degrees to change the angle. Although I'm using `tidyr::pivot_longer()`, these changes may not always result in a 'longer' data frame. 

> "Note that I don’t believe it makes sense to describe a dataset as being in “long form”. Length is a relative term, and you can only say (e.g.) that dataset A is longer than dataset B." [source](https://tidyr.tidyverse.org/dev/articles/pivot.html#wide-to-long)

```{r pivot_longer, eval=TRUE}
LomaFightsLonger <- LomaFightsWide %>%
  # specify columns to pivot into rows
  tidyr::pivot_longer(
    cols = `12 Oct 2013`:`12 Apr 2019`,
    # the name of the new variable (used to be the columns)
    names_to = "date",
    # name of the variable for what was in these columns
    values_to = "win_loss",
    # what to do about the missing values?
    na.rm = TRUE
  )
```

```{r loma-pivot-glimpse, eval=TRUE, echo=FALSE}
# fs::dir_ls("images")
knitr::include_graphics(path = "images/loma-pivot-glimpse.png")
```

I can see from the newly created data frame (`LomaFightsLonger`) that the `date` column is still formatted as a character, but I'd prefer it formatted as a `<date>`. This presents an excellent opportunity to use the new `tidyr::pivot_longer_spec()` function, because it allows me to store some additional metadata about data transformations. 

## Pivoting plus bookkeeping

We'll continue with the original Lomachenko data (`LomaFightsWide`) to demonstrate how to use the `tidyr::pivot_longer_spec` function and `spec` argument.

### *What is a `spec`?*

> *A pivoting spec is a data frame that describes the metadata stored in the column name, with one row for each column, and one column for each variable mashed into the column name.* 

Explicitly creating an object that contains data about your data is not necessarily a novel concept in R, but it's very handy when that object is similar to the other objects you're already working with (i.e. a data frame or tibble).  

Creating a `spec` for the `LomaFightsWide` data frame is a three-step process: 

#### 1) Define the arguments for reshaping the data 

The `cols` argument should include the date columns (`12 Oct 2013` through `12 Apr 2019`), the `names_to` argument is the name of the new index column (the `date`), and the `values_to` argument contains the new column for the values (`Win`/`Loss`). The results get stored into an object I will name `loma_spec`, which is a data frame with three variables in it: `.name`, `.value`, and `date` 

```{r create-loma_spec, eval=TRUE}
loma_spec <- LomaFightsWide %>%
  # specify columns to pivot into rows
  tidyr::pivot_longer_spec(
    cols = `12 Oct 2013`:`12 Apr 2019`,
    # the name of the new variable (used to be the columns)?
    names_to = "date",
    # name of the variable for what was in these columns?
    values_to = "win_loss"
  )
loma_spec %>% utils::str()
```

The three columns in `loma_spec` contain metadata (data about the data) on the transformation I'll be performing--specifically the originally columns (`.name`) and the corresponding cell values (`.value`). The other variable (`date`) gets carried over from the transformation as well. 

#### 2) Use `dplyr::mutate()` to format the `date` variable with `lubridate::dmy()` 

If I want to format the `date` variable, I can include those arguments *within* the `loma_spec` data frame.

```{r pivot_longer-spec, eval=TRUE}
# format the date
loma_spec <- loma_spec %>%
  dplyr::mutate(date = lubridate::dmy(date))
loma_spec$date %>% glimpse(78)
```

#### 3) Finally, I supply the `loma_spec` object to the `spec` argument in the `tidyr::pivot_longer_spec()` function.

Now the `loma_spec` can get supplied to the `pivot_longer()` function and the `date` variable is properly formatted (note I still need to provide the `na.rm = TRUE` argument).

```{r supply-spec, eval=TRUE}
# supply it to the pivot_longer
LomaFightsLonger <- LomaFightsWide %>%
  pivot_longer(
    spec = loma_spec,
    na.rm = TRUE
  )
```

```{r LomaFightsLonger-spec-glimpse, eval=FALSE}
LomaFightsLonger %>% dplyr::glimpse(78)
```

```{r loma-spec-date, eval=TRUE, echo=FALSE}
# fs::dir_ls("images")
knitr::include_graphics(path = "images/loma-spec-date.png")
```


## Values and variables across columns

In the example above, there was only one value (`Win`/`Loss`) per `opponent`, so many cells in the wide data structure were missing. But it isn't hard to image a situation where that wouldn't be the case. Suppose the experimental trial we introduced above also collected data at the level of the healthcare provider (`provider`), a variable documenting the date the treatment was administered (`treattdate_`), and a corresponding `treatment_` result variable.

```{r TrialDataWide}
TrialDataWide <- tibble::tribble(
       ~provider, ~treattdate_patient1, ~treattdate_patient2, ~treatment_patient1, ~treatment_patient2,
          "Z001",         "2017-11-26",         "2018-01-29",          "positive",          "negative",
          "Z002",         "2018-06-01",                   NA,          "negative",                  NA,
          "Z003",         "2018-09-11",         "2018-12-05",          "positive",          "negative",
          "Z004",         "2017-10-10",                   NA,          "positive",                  NA,
          "Z005",         "2017-02-05",         "2018-04-12",          "positive",          "positive"
       )
knitr::kable(TrialDataWide)
```

This presents are a situation where we want *both* the measurements (the `treatdate` and the `treatment`) on each `patient` and `provider` in different columns.

So I am imagining a data frame with a shape like the one below:

```{r trial-tidy-data, echo=FALSE, eval=TRUE}

```


We will still start by using the `tidyr::pivot_longer()` function, but in this case we will omit the `provider` column and see what we get. 

```{r specify-cols}
TrialDataWide %>%
  pivot_longer(cols = -provider)
```

This is closer, but I still have two measurements in each column, `name` has both `treattdate` and `treatment`, and `value` has the corresponding data.

The additional arguments I can provide to `pivot_longer` include `names_to` and `names_sep`.

in `names_to`, `.value` = a component of the variable name defines the name of the output value column.

In `spec`, `.value` = the name of the column that the values in the cells will go into






```{r }
TrialDataWide %>%
  pivot_longer(cols = -provider, 
               # these will be the new columns
               names_to = c(".value", "patient"), 
               # this is the regex we want to separate the variable names on
               names_sep = "_", 
               # what to do about the missing?
               na.rm = FALSE)
```


## Multiple variables in a single column (throwback)

You've probably noticed there are two variables in the `round_time` column. The first is the round the fight ended in (presented as `final round (total rounds)`) and the `time` in that round (`minutes:seconds`). In order to break these two variables into their own columns, I can use the `tidyr::separate()` function to split these two variables apart into their own columns. 

```{r separate-round-time, eval=TRUE, message=FALSE, warning=FALSE}
LomaFightsLonger %>%
  tidyr::separate(
    col = round_time,
    into = c("fight_rounds", "fight_time"),
    sep = ",",
    remove = FALSE
  ) %>%
  dplyr::select(round_time:fight_time)
```

This throws the following warning, 

`Expected 2 pieces. Missing pieces filled with `NA` in 5 rows [2, 3, 4, 13, 14].`

but as we can see from the table above, there is no real reason for concern. The `fight_rounds` and `fight_time` are each in their own column.

### Variables *and* values in column names

Sometimes it's not only that two different values end up in the same column, but the actual variable names are separate columns as well. This can happen when the goal of the spreadsheet is to compare or track two columns *visually*. 



Think back to the avid sports fan we introduced above, Now we will assume he's interested in tracking the epic saga between Gennady Gennadyevich Golovkin (triple G or GGG) and Saúl "Canelo" Álvarez that went from September 16th, 2017 until their rematch a year later on September 15th, 2018. Each of these fighters were considered to be at (or near) the top of their game, so many titles were on line in each fight. 

In order to track exactly what titles each fighter had before/after the fight, the following spreadsheet gets created:

```{r CaneloGGGTitles}
CaneloGGGTitles <- data.frame(
  stringsAsFactors = FALSE,
  title = c(
    "WBA (Super champion)",
    "IBF world champion",
    "WBC world champion",
    "IBO world champion",
    "The Ring world champions"
  ),
  ggg_title_date = c(
    "2014-06-03",
    "2015-10-17",
    "2016-05-18",
    "2011-12-09",
    NA
  ),
  canelo_title_date = c("2018-09-15", NA, "2018-09-15", NA, "2015-11-21"),
  ggg_title_opp = c(
    "Milton Núñez, (4 Aug 2010)",
    "David Lemieux, (17 Oct 2015)",
    "Marco Antonio Rubio, (18 Oct 2014)",
    "Lajuan Simon",
    NA
  ),
  ggg_notes = c(
    "Regular champ promoted",
    "Golovkin was stripped of this title when he failed to agree in writing to a fight with Derevyanchenko",
    "Elevated from interim status",
    "Won vacant IBO middleweight title",
    NA
  ),
  canelo_title_opp = c(
    "Gennady Golovkin",
    NA,
    "Gennady Golovkin",
    NA,
    "Miguel Cotto, (Nov 21, 2015)"
  ),
  canelo_notes = c(
    "Alvarez beats GGG, gains Super champion title",
    NA,
    "Alvarez beats GGG, gains WBC middleweight champion title",
    NA,
    "June 2018 (stripped of title), wins vacant The Ring middleweight title on Sep 15, 2018 against Gennady Golovkin"
  )
)
CaneloGGGTitles
```

As we can see, Canelo went into the fight with more title's to win (the `WBA`, `IBF` and `WBC` and `IBO` middleweight titles), and only one title to lose (`The Ring world champion` title).

*Why would the data look this way?*

Sometimes it's hard to capture data in a tidy format because the thing being measured is genuinely complicated. Remember that data are an abstraction of something we want to quantify (or count). Boxing championships (and many other things in life), are often thought of in terms of a narrative. 

RTD = A corner retirement or corner stoppage..during any rest period between rounds, a boxer refuses to continue or their corner pulls them out, thereby forcing the referee to call an end to the fight. 

UD =  all three judges agree on which fighter won the match.

MD = In a majority decision, two of the three judges agree on which fighter won the match, while the third judge indicates that neither fighter won (i.e., a "draw").



These new functions borrow ideas from the [`cdata`](https://winvector.github.io/cdata/) and [`data.table`](https://github.com/Rdatatable/data.table/wiki) packages.


```{r LomaFightsLonger-round_time-assign, eval=TRUE, results='hide', echo=FALSE, warning=FALSE, message=FALSE}
LomaFightsLonger <- LomaFightsLonger %>%
  tidyr::separate(
    col = round_time,
    into = c("fight_rounds", "fight_time"),
    sep = ","
  )
LomaFightsLonger %>% glimpse(78)
```


[here](http://fightland.vice.com/blog/the-pivots-and-precision-of-vasyl-lomachenko)

Assume a physician wants to compare the efficacy of a new statin drug (a cholesterol lowering medicine) against the currently recommended medication. 

After consenting `415` patients with high cholesterol, the physician randomly selects a sample of `209` patients to receive the new drug for six months, while the other `206` patients get a six-month course of the current drug. 

*NOTE: This is a simplification of a clinical trial. In a true experiment, there are many other factors to consider.*

Below is an example of how these data might get entered into a spreadsheet.

```{r import-TrialDataPrePost, message=FALSE, warning=FALSE}
TrialDataPrePost <- read_csv("data/trial-data-pre-post.csv")
knitr::kable(
TrialDataPrePost %>% utils::head())
```

Imagine a hypothetical chain of events for this trial, starting with the first and following in the order they occur: 

1. A patient with high cholesterol gets randomized into the `treatment` condition, given an ID number (`patient id trt`), then a cholesterol measurement is taken and entered into the `baseline treatment` column. 

2. A second patient with high cholesterol comes into the physician's office, is randomized into the `control` group, given their ID (`patient id cont`), and their baseline cholesterol measurement is recorded. 

3. The process continues, and all `415` patients with high cholesterol are assigned to a group (`treatment` or `control`), given an ID (`patient id`), then prescribed the appropriate medication. 

4. Six months after their initial appointment and baseline measurements, both groups of patients have their cholesterol measured again (in the `post` columns). 

Given this timeline, does it seem *that* strange to enter the data in a spreadsheet like the `TrialDataPrePost` data frame? I don't think so, and here are some reasons why:

1. This spreadsheet starts out as a record-keeping tool, and it's doing just that: something happens, then it gets documented 
2. Tables like this can be read left-to-right, and the columns and rows are added *as they occur* 
3. The physician (or whoever is entering the data) can see a lot of the data on the screen 

We can actually think of the `TrialDataPrePost` data frame as containing *two* data frames: the `Treatment` data (with `209` patients), and the `Control` data (with `206` patients). 

A little `dplyr` action will can separate these data frames. 

```{r Treatment}
Treatment <- TrialDataPrePost %>% 
    dplyr::select(pat_id_trt,
                  `baseline treatment`,
                  `post treatment`)
Treatment %>% glimpse(78)
```

```{r Control}
Control <- TrialDataPrePost %>% 
    dplyr::filter(!is.na(pat_id_cont)) %>% 
    dplyr::select(pat_id_cont,
                  `baseline control`,
                  `post control`)
Control %>% glimpse(78)
```




```{r}
# trt <- runif(209, min = 160, max = 200)
# cont <- runif(206, min = 160, max = 200)
# A <- tibble::enframe(x = trt, value = "baseline treatment")
# B <- tibble::enframe(x = cont, value = "baseline control")
# write_csv(as.data.frame(A), "data/A.csv")
# write_csv(as.data.frame(B), "data/B.csv")
# trt2 <- runif(209, min = 150, max = 190)
# cont2 <- runif(206, min = 160, max = 200)
# A2 <- tibble::enframe(x = trt2, value = "post treatment")
# B2 <- tibble::enframe(x = cont2, value = "post control")
# write_csv(as.data.frame(A2), "data/A2.csv")
# write_csv(as.data.frame(B2), "data/B2.csv")
```


```{r TrialData, eval=TRUE, message=FALSE, warning=FALSE, echo=FALSE}
base::source("data/trial-data.R")
TrialData %>% utils::head()
```













